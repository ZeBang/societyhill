LL.oold=LL.old
RR.oold=RR.old
# estimate LL0
temp1 <- tensor(xx[1:(T-1),,,drop=FALSE],RR.old,3,2)  # (T-1) * p * q
AA <- tensor(temp1,temp1,c(1,3),c(1,3))
BB <- tensor(xx[2:T,,,drop=FALSE],temp1,c(1,3),c(1,3))
LL <- BB%*%ginv(AA)
U <- svd(LL%*%t(BB))$u[,1:k1]
LL <- U%*%t(U)%*%LL
# update for next iteration
a=svd(LL,nu=0,nv=0)$d[1]
LL=LL/a
dis3=sum((LL-LL.old)^2)
LL.old <- LL
# estimate RR0
temp1 <- tensor(xx[1:(T-1),,,drop=FALSE],LL.old,2,2)  # (T-1) * q * p
AA <- tensor(temp1,temp1,c(1,3),c(1,3))
BB <- tensor(xx[2:T,,,drop=FALSE],temp1,c(1,2),c(1,3))
RR <- BB%*%ginv(AA)
U <- svd(RR%*%t(BB))$u[,1:k2]
RR <- U%*%t(U)%*%RR
# update for next iteration
dis3=dis3+sum((RR-RR.old)^2)
RR.old <- RR
# update for the next iteration
dis1 <- sqrt(sum((kronecker(t(RR),LL)-kronecker(t(RR.oold),LL.oold))^2))
dis3 = sqrt(dis3)
dis <- dis3
iiter <- iiter + 1
#print(max(abs(eigen(LL)$values)))
#print(max(abs(eigen(RR)$values)))
if(print.true==TRUE){
print(dis)
print(paste('iiter num=',iiter))
}
}
a <- sqrt(sum(LL^2))
LL <- LL / a
RR <- RR * a
res=xx[2:T,,,drop=FALSE] - aperm(tensor(tensor(xx[1:(T-1),,,drop=FALSE],RR,3,2),LL,2,2),c(1,3,2))
Sig <- matrix(tensor(res,res,1,1),p*q)/(T-1)
bic <- T*p*q*log(sum(res^2/(T*p*q))) ##+log(T*p*q)*(bic.penalty(p,k1)+bic.penalty(q,k2))
cov <- matAR.RR.se(LL,RR,k1,k2,method="RRLSE",Sigma.e=Sig,RU1=diag(k1),RV1=diag(k1),RU2=diag(k2),RV2=diag(k2),mpower=100)
sd <- list(sqrt(array(diag(cov$Sigma)[1:p^2], c(p,p))/T), sqrt(array(diag(cov$Sigma)[(p^2+1):(p^2+q^2)], c(q,q))/T))
loading = list(U1=svd(LL)$u,V1=svd(LL)$v,U2=svd(RR)$u,V2=svd(RR)$v)
return(list(A1=LL,A2=RR,loading=loading,res=res,Sig=Sig,BIC=bic,niter=iiter-1,cov=cov,sd=sd))
}
MAR1.CC <- function(xx,k1,k2,A1.init=NULL,A2.init=NULL,Sigl.init=NULL,Sigr.init=NULL,niter=200,tol=1e-4,print.true = FALSE){
# xx: T * p * q
# X_t = LL X_{t-1} RR' + E_t ### NOTE! This function is written with RR'.
# Sig = cov(vec(E_t)) = Sigr \otimes Sigl
# optimization criterion is likelihood
# iterative algorithm between LL <--> Sigma_l <--> RR <--> Sig_r
# Return LL, RR, Sigl, Sigr
dd=dim(xx)
T <- dd[1]
p <- dd[2]
q <- dd[3]
if(is.null(A1.init)){
LL.old <- diag(p)
} else{
LL.old <- A1.init
}
if(is.null(A2.init)){
RR.old <- diag(q)
} else{
RR.old <- A2.init
}
if(is.null(Sigl.init)){
Sigl.old <- diag(p)
} else{
Sigl.old <- Sigl.init
}
if(is.null(Sigr.init)){
Sigr.old <- diag(q)
} else{
Sigr.old <- Sigr.init
}
Tol=tol*sqrt(p^2+q^2)
dis <- 1
iiter <- 1
while(iiter <= niter & dis >= Tol){
## Save old
LL.oold=LL.old
RR.oold=RR.old
Sigl.oold=Sigl.old
Sigr.oold=Sigr.old
# estimate LL0 and Sigl
Sigr.inv.old <- ginv(Sigr.old)
temp1 <- tensor(xx[1:(T-1),,,drop=FALSE],RR.old,3,2)  # (T-1) * p * q
temp2 <- tensor(temp1,Sigr.inv.old,3,1)  # (T-1) * p * q
AA <- tensor(temp1,temp2,c(1,3),c(1,3))
BB <- tensor(xx[2:T,,,drop=FALSE],temp2,c(1,3),c(1,3))
LL <- BB%*%ginv(AA)
res <- xx[2:T,,,drop=FALSE] - aperm(tensor(tensor(xx[1:(T-1),,,drop=FALSE],RR.old,3,2),LL,2,2),c(1,3,2)) # (T-1) * p * q
temp <- tensor(res,Sigr.inv.old,3,1) # (T-1) * p * q
Sigl <- tensor(temp,res,c(1,3),c(1,3))/T/q
Sigl.spec <- eigen(Sigl)
Sigl.root <- Sigl.spec$vectors%*%diag(sqrt(Sigl.spec$values))%*%t(Sigl.spec$vectors)
Sigl.root.inv <- Sigl.spec$vectors%*%diag(1/sqrt(Sigl.spec$values))%*%t(Sigl.spec$vectors)
U <- svd(Sigl.root.inv%*%LL%*%t(BB)%*%Sigl.root.inv)$u[,1:k1]
LL <- Sigl.root%*%U%*%t(U)%*%Sigl.root.inv%*%LL
res <- xx[2:T,,,drop=FALSE] - aperm(tensor(tensor(xx[1:(T-1),,,drop=FALSE],RR.old,3,2),LL,2,2),c(1,3,2)) # (T-1) * p * q
temp <- tensor(res,Sigr.inv.old,3,1) # (T-1) * p * q
Sigl <- tensor(temp,res,c(1,3),c(1,3))/T/q
# update for next iteration
a=svd(LL,nu=0,nv=0)$d[1]
LL=LL/a
dis3=sum((LL-LL.old)^2)
LL.old <- LL
Sigl.old <- Sigl
# estimate RR0 and Sigr
Sigl.inv.old <- ginv(Sigl.old)
temp1 <- tensor(xx[1:(T-1),,,drop=FALSE],LL.old,2,2)  # (T-1) * q * p
temp2 <- tensor(temp1,Sigl.inv.old,3,1)  # (T-1) * q * p
AA <- tensor(temp1,temp2,c(1,3),c(1,3))
BB <- tensor(xx[2:T,,,drop=FALSE],temp2,c(1,2),c(1,3))
RR <- BB%*%ginv(AA)
res <- xx[2:T,,,drop=FALSE] - aperm(tensor(tensor(xx[1:(T-1),,,drop=FALSE],RR,3,2),LL.old,2,2),c(1,3,2)) # (T-1) * p * q
temp <- tensor(res,Sigl.inv.old,2,1) # (T-1) * q * p
Sigr <- tensor(temp,res,c(1,3),c(1,2))/T/p
Sigr.spec <- eigen(Sigr)
Sigr.root <- Sigr.spec$vectors%*%diag(sqrt(Sigr.spec$values))%*%t(Sigr.spec$vectors)
Sigr.root.inv <- Sigr.spec$vectors%*%diag(1/sqrt(Sigr.spec$values))%*%t(Sigr.spec$vectors)
U <- svd(Sigr.root.inv%*%RR%*%t(BB)%*%Sigr.root.inv)$u[,1:k2]
RR <- Sigr.root%*%U%*%t(U)%*%Sigr.root.inv%*%RR
res <- xx[2:T,,,drop=FALSE] - aperm(tensor(tensor(xx[1:(T-1),,,drop=FALSE],RR,3,2),LL.old,2,2),c(1,3,2)) # (T-1) * p * q
temp <- tensor(res,Sigl.inv.old,2,1) # (T-1) * q * p
Sigr <- tensor(temp,res,c(1,3),c(1,2))/T/p
# update for next iteration
dis3=dis3+sum((RR-RR.old)^2)
RR.old <- RR
Sigr.old <- Sigr
a <- eigen(Sigl)$values[1]
Sigl <- Sigl / a
Sigr <- Sigr * a
### cat(eigen(Sigl)$values[1]," ",eigen(Sigr)$values[1], " ")
# update for the next iteration
dis1 <- sqrt(sum((kronecker(t(RR),LL)-kronecker(t(RR.oold),LL.oold))^2))
### cat(dis1," ")
dis2 <- sqrt(sum((kronecker(Sigr,Sigl)-kronecker(Sigr.oold,Sigl.oold))^2))
### cat(dis2," ",dis3,"\n")
dis3 = sqrt(dis3)
### dis <- max(dis1,dis2)
dis <- dis3
Sigr.old <- Sigr
Sigl.old <- Sigl
iiter <- iiter + 1
if(print.true==TRUE){
print(LL)
print(RR)
}
}
a <- sqrt(sum(LL^2))
LL <- LL / a
RR <- RR * a
Sig <- kronecker(Sigr,Sigl)
# cov <- matAR.RR.se(LL,RR,k1,k2,method="RRMLE",Sigma1=Sigl,Sigma2=Sigr,RU1=diag(k1),RV1=diag(k1),RU2=diag(k2),RV2=diag(k2),mpower=100)
cov = MAR1.RRCC.SE(LL,RR,k1,k2,Sigl,Sigr,RU1=diag(k1),RV1=diag(k1),RU2=diag(k2),RV2=diag(k2),mpower=100)
sd <- list(sqrt(array(diag(cov$Sigma)[1:p^2], c(p,p))/T), sqrt(array(diag(cov$Sigma)[(p^2+1):(p^2+q^2)], c(q,q))/T))
loading = list(U1=svd(LL)$u,V1=svd(LL)$v,U2=svd(RR)$u,V2=svd(RR)$v)
return(list(A1=LL,A2=RR,loading=loading,res=res,Sig1=Sigl,Sig2=Sigr,Sig=Sig,niter=iiter-1, cov=cov, sd=sd))
}
tenAR.SE.LSE <- function(dim, r, p, K, t, AX, A, Sigma){
# dim = dim; r=R; p=P; K=K; t=t; AX = AX; A=A.new; Sigma=Sig;
pdim = prod(dim) # d1d2d3
fdim = dim**2
ndim <- sum(fdim) # d1^2+d2^2+d^3
Gamma <- matrix(0,sum(r)*ndim,sum(r)*ndim)
n = 0
for (i in c(1:p)){
for (j in c(1:r[i])){
for (k in c(1:(K-1))){
r1 <- matrix(0, sum(r)*ndim, 1)
a = as.vector(A[[i]][[j]][[k]])
r1[( n*ndim + sum(fdim[0:(k-1)]) + 1): (n*ndim + sum(fdim[0:k])),] = a
Gamma = Gamma + r1 %*% t(r1)
}
n = n + 1
}
}
WT = c(); Q = list(); perm = list(); size = list()
for (i in c(1:p)){
for (j in c(1:r[i])){
for (k in c(1:K)){
if (length(Q) < K){
perm[[k]] = c(k+1, (1:K)[-k] + 1, 1)
size[[k]] = c(dim[k], prod(dim[-k]), t)
s = if (is.na(prod(dim[(k+1):K]))) 1 else prod(dim[(k+1):K])
Q[[k]] = kronecker(diag(s), pm(dim[k], prod(dim[0:(k-1)])))
}
# AXX = AX[[i]][[j]][[k]] # AXX = rTensor::ttl(xx, A.new[[i]][[j]][-k], c(2:(K+1))[-k])
AXX = asub(AX[[i]][[j]][[k]], (1+p-i):(t-i), 1, drop=FALSE)
AXfold = array(aperm(AXX@data, perm[[k]]), size[[k]])
AXI = apply(AXfold,3,function(x){kronecker(x, diag(dim[k])) %*% Q[[k]]})
AXI.array <- array(AXI,c(dim[k]^2,pdim,t))
WT <- abind(WT, AXI.array,along=1)
}
}
}
WT = aperm(WT, c(3,1,2))
WSigma <- tensor(WT,Sigma,3,1) #t*(d1^2+d2^2+d^3)*(d1d2d3)
EWSigmaWt <- tensor(WSigma,WT,c(3,1),c(3,1))/t
H <- tensor(WT,WT,c(3,1),c(3,1))/t + Gamma #r(d1^2+d2^2+d^2)*r(d1^2+d2^2+d^3)
Hinv <- solve(H)
Xi <- Hinv %*% EWSigmaWt %*% Hinv
return(Xi/t)
}
tenAR.SE.MLE <- function(dim, r, p, K, t, AX, A, Sigma){
# dim = dim; r=R; p=P; K=K; t=t; AX = AX; A=A.new; Sigma=Sig;
pdim = prod(dim) # d1d2d3
fdim = dim**2
ndim <- sum(fdim) # d1^2+d2^2+d^3
Gamma <- matrix(0,sum(r)*ndim,sum(r)*ndim)
r1 <- matrix(0, sum(r)*ndim, 1)
n = 0
for (i in c(1:p)){
for (j in c(1:r[i])){
for (k in c(1:(K-1))){
a = as.vector(A[[i]][[j]][[k]])
r1[( n*ndim + sum(fdim[0:(k-1)]) + 1): (n*ndim + sum(fdim[0:k])),] = a
Gamma = Gamma + r1 %*% t(r1)
}
n = n + 1
}
}
WT = c(); Q = list(); perm = list(); size = list()
for (i in c(1:p)){
for (j in c(1:r[i])){
for (k in c(1:K)){
if (length(Q) < K){
perm[[k]] = c(k+1, (1:K)[-k] + 1, 1)
size[[k]] = c(dim[k], prod(dim[-k]), t)
s = if (is.na(prod(dim[(k+1):K]))) 1 else prod(dim[(k+1):K])
Q[[k]] = kronecker(diag(s), pm(dim[k], prod(dim[0:(k-1)])))
}
AXX = AX[[i]][[j]][[k]]
AXfold = array(aperm(AXX@data, perm[[k]]), size[[k]])
AXI = apply(AXfold,3,function(x){kronecker(x, diag(dim[k])) %*% Q[[k]]})
AXI.array <- array(AXI,c(dim[k]^2,pdim,t))
WT <- abind(WT, AXI.array,along=1)
}
}
}
WT = aperm(WT, c(3,1,2))
WSigma <- tensor(WT,solve(Sigma),3,1)
EWSigmaWt <- tensor(WSigma,WT,c(3,1),c(3,1))/t
H <- EWSigmaWt + Gamma
Hinv <- solve(H)
Xi <- Hinv %*% EWSigmaWt %*% Hinv
return(Xi/t)
}
tenAR.bic <- function(xx, rmax=5){
if (mode(xx) != "S4") {xx <- rTensor::as.tensor(xx)}
dim <- xx@modes[-1]
t <- xx@modes[[1]]
ans <- c()
for (r in c(1:rmax)){
est <- tenAR.LS(xx, R=r, P=1)
res <- est$res
ans[r] <- IC(xx,res,r,t, dim)
}
which.min(ans)
}
#' Plot Matrix-Valued Time Series
#'
#' Plot matrix-valued time series, can be also used to plot a given slice of a tensor-valued time series.
#'@name mplot
#'@rdname mplot
#'@aliases mplot
#'@export
#'@importFrom graphics par
#'@param xx  \eqn{T \times d_1 \times d_2} matrix-valued time series. Note that the number of mode is 3, where the first mode is time.
#'@return a figure.
#'@examples
#' dim <- c(3,3,3)
#' xx <- tenAR.sim(t=50, dim, R=2, P=1, rho=0.5, cov='iid')
#' mplot(xx[1:30,,,1])
mplot <- function(xx){
if (mode(xx) == "S4"){xx = xx@data}
dim = dim(xx)
time = array(c(1:dim[1]),dim[1])
opar <- par(mfrow=c(dim[2],dim[3]),mai=0.05*c(1,1,1,1),oma=c(2,2,0,0))
on.exit(par(opar))
for(i in 1:dim[2]){
for(j in 1:dim[3]){
if(i!=dim[2] & j!=1){
plot(time,xx[,i,j],type='l',xaxt='n',yaxt='n',ylim=range(xx[,i,]))
}
if(i!=dim[2] & j==1){
plot(time,xx[,i,j],type='l',xaxt='n',ylim=range(xx[,i,]))
}
if(i==dim[2] & j!=1){
plot(time,xx[,i,j],type='l',yaxt='n',ylim=range(xx[,i,]))
}
if(i==dim[2] & j==1){
plot(time,xx[,i,j],type='l',ylim=range(xx[,i,]))
}
}
}
}
#' Plot ACF of Matrix-Valued Time Series
#'
#' Plot ACF of matrix-valued time series, can be also used to plot ACF of a given slice of a tensor-valued time series.
#'@name mplot.acf
#'@rdname mplot.acf
#'@aliases mplot.acf
#'@export
#'@importFrom graphics par
#'@importFrom graphics plot
#'@importFrom stats acf
#'@param xx  \eqn{T \times d_1 \times d_2} matrix-valued time series. Note that the number of mode is 3, where the first mode is time.
#'@return a figure.
#'@examples
#' dim <- c(3,3,3)
#' xx <- tenAR.sim(t=50, dim, R=2, P=1, rho=0.5, cov='iid')
#' mplot.acf(xx[1:30,,,1])
mplot.acf <- function(xx){
if (mode(xx) == "S4"){xx = xx@data}
dim = dim(xx)
opar <- par(mfrow=c(dim[2],dim[3]),mai=0.05*c(1,1,1,1),oma=c(2,2,0,0))
on.exit(par(opar))
for(i in 1:dim[2]){
for(j in 1:dim[3]){
if(i!=dim[2] & j!=1){
acf(xx[,i,j])
}
if(i!=dim[2] & j==1){
acf(xx[,i,j])
}
if(i==dim[2] & j!=1){
acf(xx[,i,j])
}
if(i==dim[2] & j==1){
acf(xx[,i,j])
}
}
}
}
#' Predictions for Tensor Autoregressive Models
#'
#' Prediction based on the tensor autoregressive model or reduced rank MAR(1) model. If \code{rolling = TRUE}, returns the rolling forecasts.
#'@name tenAR.predict
#'@rdname tenAR.predict
#'@aliases tenAR.predict
#'@export
#'@importFrom abind abind
#'@param object a model object returned by \code{tenAR.est()}.
#'@param n.head prediction horizon.
#'@param xx \eqn{T^{\prime} \times d_1 \times \cdots \times d_K} new tensor time series to be used for prediction. Must have at least \code{n.ahead} length.
#'@param rolling TRUE or FALSE, rolling forecast, is FALSE by default.
#'@param n0 only if \code{rolling = TRUE}, the starting point of rolling forecast.
#'@return
#'a tensor time series of length \code{n.head} if \code{rolling = FALSE};
#'
#'a tensor time series of length \eqn{T^{\prime} - n_0 - n.head + 1} if \code{rolling = TRUE}.
#'@seealso 'predict.ar' or 'predict.arima'
#'@examples
#' set.seed(333)
#' dim <- c(2,2,2)
#' t = 20
#' xx <- tenAR.sim(t, dim, R=2, P=1, rho=0.5, cov='iid')
#' est <- tenAR.est(xx, R=1, P=1, method="LSE")
#' pred <- tenAR.predict(est, n.head = 1, xx = xx)
#' # rolling forcast
#' n0 = t - min(50,t/2)
#' pred.rolling <- tenAR.predict(est, n.head = 5, xx = xx, rolling=TRUE, n0)
#'
#' # prediction for reduced rank MAR(1) model
#' dim <- c(2,2)
#' t = 20
#' xx <- tenAR.sim(t, dim, R=1, P=1, rho=0.5, cov='iid')
#' est <- matAR.RR.est(xx, method="RRLSE", k1=1, k2=1)
#' pred <- tenAR.predict(est, n.head = 1, xx = xx)
#' # rolling forcast
#' n0 = t - min(50,t/2)
#' pred.rolling <- tenAR.predict(est, n.head = 5, xx = NULL, rolling=TRUE, n0)
tenAR.predict <- function(object, n.head=1, xx=NULL, rolling=FALSE, n0=NULL){
if (is.null(object$SIGMA)){method = "LSE"} else {method = "MLE"}
if (!is.null(object$A1)){
A <- list(list(list(object$A1, object$A2)))
if (is.null(object$Sig1)){
method = "RRLSE"
} else {
method = "RRMLE"
}
} else if (!is.null(object$coef)){
A <- list(list(object$coef))
method = "VAR"
} else {
A <- object$A
}
if (mode(xx) != "S4") {xx <- rTensor::as.tensor(xx)}
if (rolling == TRUE){
return(predict.rolling(A, xx, n.head, method, n0))
}
P <- length(A)
R <- sapply(c(1:P), function(l){length(A[[l]])})
K <- xx@num_modes - 1
dim <- xx@modes
ttt <- (dim[1]+1):(dim[1]+n.head)
for(tt in ttt){
L1 = 0
for (l in c(1:P)){
if (R[l] == 0) next
L1 <- L1 + Reduce("+",lapply(c(1:R[l]), function(n) {rTensor::ttl(asub(xx, tt-l, 1, drop=FALSE), A[[l]][[n]], (c(1:K) + 1))}))
}
xx <- as.tensor(abind(xx@data, L1@data, along=1))
}
return(asub(xx@data, ttt, 1, drop=FALSE))
}
predict.rolling <- function(A, xx, n.head, method, n0){
if ((method == "RRLSE") || (method == "RRMLE")){
k1 <- rankMatrix(A[[1]][[1]][[1]])
k2 <- rankMatrix(A[[1]][[1]][[2]])
}
P <- length(A)
R <- sapply(c(1:P), function(l){length(A[[l]])})
K <- xx@num_modes - 1
dim <- xx@modes
t <- dim[1]
if(is.null(n0)){n0 = t - min(50,t/2)}
ttt <- (n0):(t - n.head)
print(paste(K,R,P))
for(tt in ttt){
tti <- tt - ttt[1] + 1
print(paste("rolling forcast t =", tti))
if (method == "RRLSE"){
model <- MAR1.RR(asub(xx@data, 1:tt, 1, drop=FALSE), k1, k2)
A <- list(list(list(model$A1, model$A2)))
} else if (method == "RRMLE"){
model <- MAR1.CC(asub(xx@data, 1:tt, 1, drop=FALSE), k1, k2)
A <- list(list(list(model$A1, model$A2)))
} else {
model = tenAR.est(asub(xx@data, 1:tt, 1, drop=FALSE), R, c(P,0), method)
A <- model$A
}
L1 = 0
for (l in c(1:P)){
if (R[l] == 0) next
L1 <- L1 + Reduce("+",lapply(c(1:R[l]), function(n) {rTensor::ttl(asub(xx, tt-l+1, 1, drop=FALSE), A[[l]][[n]], (c(1:K) + 1))}))
}
if (tti == 1){xx.pred = L1@data} else {xx.pred = abind(xx.pred, L1@data, along=1)}
}
return(xx.pred)
}
.getpos <- function(mode, rank){
pos = 0
for (k in c(1:length(mode))){
if (k > 1){mode[k] = mode[k] - 1}
pos = pos + rank[k]*mode[k]
}
return(pos)
}
.getrank <- function(dim){
rank = array(1, length(dim))
for (k in c(1:length(dim))){
if (k > 1){ for (q in c(1:(k-1))){rank[k] = rank[k]*(rev(dim)[q])}}
}
return(rank)
}
.remove.mean <- function(xx){
dim <- xx@modes
m <- apply(xx@data, c(2:xx@num_modes), mean)
mm <- aperm(array(m, c(dim[-1],dim[1])), c(xx@num_modes,c(1:(xx@num_modes-1))))
return(xx - mm)
}
## out5.p=MAR1.CC(X.Mat[1:(tt-1),,],k1,k2,LL.init=out1.p$LL,RR.init=t(out1.p$RR))
## pred5=out5.p$LL%*%X.Mat[(tt-1),,]%*%t(out5.p$RR)
out5.p=matAR.RR.est(X.Mat[1:(tt-1),,], method="RRMLE", A1.init=out1.p$LL, A2.init=t(out1.p$RR),Sig1.init=NULL,Sig2.init=NULL,k1=k1, k2=k2, niter=100,tol=1e-6)
##k1=r1.hat
##k2=r2.hat
k1=2
k2=2
tti=tt-ttt[1]+1
out1.p=MAR1.PROJ(X.Mat[1:(tt-1),,])
## out5.p=MAR1.CC(X.Mat[1:(tt-1),,],k1,k2,LL.init=out1.p$LL,RR.init=t(out1.p$RR))
## pred5=out5.p$LL%*%X.Mat[(tt-1),,]%*%t(out5.p$RR)
out5.p=matAR.RR.est(X.Mat[1:(tt-1),,], method="RRMLE", A1.init=out1.p$LL, A2.init=t(out1.p$RR),Sig1.init=NULL,Sig2.init=NULL,k1=k1, k2=k2, niter=100,tol=1e-6)
out5.p$A1
out5.p$A2
##k1=r1.hat
##k2=r2.hat
k1=2
k2=2
for(tt in ttt){
tti=tt-ttt[1]+1
out1.p=MAR1.PROJ(X.Mat[1:(tt-1),,])
## out2.p=MAR1.LS(X.Mat[1:(tt-1),,])
## out4.p=MAR1.RR(X.Mat[1:(tt-1),,],k1,k2,LL.init=out1.p$LL,RR.init=t(out1.p$RR))
## pred4=out4.p$LL%*%X.Mat[(tt-1),,]%*%t(out4.p$RR)
## out4.p=matAR.RR.est(X.Mat[1:(tt-1),,], method="RRLSE", A1.init=out1.p$LL, A2.init=t(out1.p$RR),Sig1.init=NULL,Sig2.init=NULL,k1=k1, k2=k2, niter=100,tol=1e-6)
## pred4=out4.p$A1%*%X.Mat[(tt-1),,]%*%t(out4.p$A2)
# out.pred.ss[8,tti]=sum((X.Mat[tt,,]-pred4)**2)
## out5.p=MAR1.CC(X.Mat[1:(tt-1),,],k1,k2,LL.init=out1.p$LL,RR.init=t(out1.p$RR))
## pred5=out5.p$LL%*%X.Mat[(tt-1),,]%*%t(out5.p$RR)
out5.p=matAR.RR.est(X.Mat[1:(tt-1),,], method="RRMLE", A1.init=out1.p$LL, A2.init=t(out1.p$RR),Sig1.init=NULL,Sig2.init=NULL,k1=k1, k2=k2, niter=100,tol=1e-6)
# pred5=out5.p$A1%*%X.Mat[(tt-1),,]%*%t(out5.p$A2)
# out.pred.ss[9,tti]=sum((X.Mat[tt,,]-pred5)**2)
}
tti
library(devtools)
getwd()
setwd("C:/Users/zeban/OneDrive/R package paper/pkg/tensorTS_0.1.3/tensorTS")
getwd()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::build_manual()
devtools::check()
devtools::build()
