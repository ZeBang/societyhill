---
title: "tensorTS Package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Factor and Autoregressive Models for Tensor Time Series

The R package **tensorTS** includes methods in our recent papers, including [Factor Models](https://arxiv.org/abs/1905.07530) and [Autoregressive Models](https://arxiv.org/abs/1812.08916) for High-Dimensional tensor Time Series. We demonstrate some examples for how to use our package here. To have more details please see the manual file for the full documentation.

#### Installation

Temporarily, we use GitHub to host this package source code then users can install the package directly from GitHub using the `install_github` function in the [devtools](https://github.com/r-lib/devtools#readme) package:
```{r, eval=FALSE}
library(devtools)
install_github("zebang/tensorTS")
```

Remark: You may need download latest [Rtools](https://cran.r-project.org/bin/windows/Rtools/) if error message says so.

## Autoregressive Models

We collect all estimation methods in one function `TenAR`. So you can just use this single function to have all estimation methods you want to use.

For demonstration, we first randomly generate some coefficient matrices and tensor time series as follows,
```{r}
library(tensorTS)
dim <- c(4,5,6) # dimension of tensor at time t is 4 * 5 * 6
A <- tenAR.A(dim, R=1, P=1, rho=0.5) # randomly generate coefficient matrices with number of terms R = 1
xx <- tenAR.xx(t=500, A, setting="iid") # generate tensor time series with AR(1) structure
```

We can choose the number of terms by function `bic`,

```{r, eval=FALSE}
r = tenAR.bic(xx)
```


To use estimation function `tenAR`, you need specify the estimation method you want to use by parameter `method`, which can be

* "LSE" (TenAR(p) iterative estimation), 
* "MLE" (TenAR(p) iterative estimation with Kronecker covariance structure),
* "RRLSE" (Reduced Rank MAR(1) iterative estimation), 
* "RRMLE" (Reduced Rank MAR(1) iterative estimation with Kronecker covariance structure),
* "PROJ" (Projection method),
* "AR" (stacked VAR(1) model).

Specify you want to use multiple term model or one term model by parameter `r`, and the order in TenAR($p$) by parameter `p`, For example, if we want to estimate by `LSE` method under multiple term model with number of terms $r=2$ in TenAR(1) with $p=1$, run as follows,

```{r, eval=FALSE}
model = tenAR(xx, R=2, P=1, method="LSE")
```

The return of this function includes,

* `A` (estimator of coefficient matrices), 
* `res` (residual of the model), 
* `Sig` (covariance matrix cov(vec(E_t))), 

and other parameters depends on the method you used. These parameters are storage in the form of a list, so you can use `$` to extract them,

```{r, eval=FALSE}
A.estimate = model$A
residual = model$res
Sigma = model$Sig
```

#### Prediction

For predictions, we have function `tenAR.predict` with following parameters. Specifically, using given model parameters `object`, start from the last time point $X_t$ in `data`, we obtain the one step ahead prediction $X_{t+1}$. Then again using given model parameters `object` to obtain $X_{t+2}$. Repeat this process to $X_{t + n.head}$. 


* `object` a fit from `tenAR`
* `data` data to which to apply the prediction.
* `n.head` number of steps ahead at which to predict.
* `method` method used by rolling forecast. default is "LSE".

```{r, eval=FALSE}
pred.xx <- tenAR.predict(model, xx, n.head = 5, method = "LSE")
```

We also have out-sample rolling forecast prediction function `tenAR.rolling` with following parameters. Specifically, using given model parameters `object`, start from the last time point $X_t$ in `data`, we obtain the one step ahead prediction $X_{t+1}$. Then fit the corresponding model using all available `data` and $X_{t+1}$ to obtain $X_{t+2}$. Repeat this process to $X_{t + n.head}$. 

* `object` a fit from `tenAR`
* `data` data to which to apply the prediction.
* `n.head` number of steps ahead at which to predict.
* `method` method used by rolling forecast. default is "LSE".


```{r, eval=FALSE}
pred.xx <- tenAR.rolling(model, data=xx, n.head = 5, method = "LSE")
```


#### Plotting

We offered the function to plot the matrix-valued time series. This function can be applied to any mode of tensors. For example, we want to plot the second and third mode by given the fourth mode equals 1. By default, the order of first mode represents order of time.

```{r, fig.width=6,fig.height=4}
mplot(xx[1:50,,,1])
```

## Reduced Rank Autoregressive Models

We generate a matrix-valued time series and estimate it by Reduced Rank Autoregressive model.

```{R eval=FALSE}
dim <- c(4,5) # dimension of matrix at time t is 4 * 5 
A <- TenAR.A(dim, R=1, P=1, rho=0.5) # randomly generate coefficient matrices with number of terms R = 1
xx <- TenAR.xx(t=500, A, setting="iid") # generate tensor time series with AR(1) structure
model <- MAR1.RR(xx, k1=2, k2=2)
```
or
```{R eval=FALSE}
model <- TenAR(xx, R=1, P=1, method="RRLSE", k1=2, k2=2)
```


## Tensor Factor Models

The factor model part contains two main functions : tenFM.est for factor estimation and a rank estimation function rank.est.


#### Tensor Factor Estimation

We use the same set of data in tenAR model, here we specify a rank r.
```{r eval=FALSE}
# Use the same simulated data x as in tenAR part
xx <- as.tensor(xx)
r <- c(2,2,2)  # Pre-specified rank
```


To use estimation function `tenFM.est`, you need to specify the rank of factor and estimation method you want to use by parameter `method`, which can be

* "TIPUP" (Time series Inner-Product Unfolding Procedure)
* "TOPUP" (Time series Outer-Product Unfolding Procedure)

You can also choose to do the estimation iteratively or not, by specifying the boolean variable `iter`.


```{r, eval=FALSE}
model = TenFM.est(xx, r, method="TIPUP",iter=TRUE)
```

The return of this function includes :

* `Ft` (estimated factor), 
* `Ft.all` (sum of Ft over time), 
* `Q` (loading matrix), 
* `xhat` (the fitted series), 
* `norm.percent` (percentage of residual of the model, in Frobenius norm), 
* `niter` (iterations used before stopping).

```{r, eval=FALSE}
Ft = model$Ft
Loading = model$Q
```


#### Factor Rank determination

The function Rank.est is used for determining the rank of factor. A few options can be chosen, more details can be referenced in the paper: Rank Determination in Tensor Factor Model.

* `method` 'TIPUP' and 'TOPUP', the same as in factor estimation function
* `rank` The method to estimate rank
     + 'BIC': Bayesian information criterion
     + 'ER' : Eigen ratio method
* `iter` Boolean variable to decide to use an iterative approach or not
* `inputr` Boolean variable, if FALSE, update the rank by estimation from last iteration; if TRUE, keep using the input rank
* `penalty` Decide which penalty function to use
     + When rank= 'BIC' :
         + if penalty=1, $g_1= \frac{h_0 d^{2-2\nu}}{T}$log($\frac{dT}{d+T}$)
         + if penalty=2, $g_2= h_0 d^{2-2\nu}(\frac{1}{T}+\frac{1}{d})$log($\frac{dT}{d+T}$)
         + if penalty=3, $g_3= \frac{h_0 d^{2-2\nu}}{T}$log(min{$d$,$T$})
         + if penalty=4, $g_4= h_0 d^{2-2\nu}(\frac{1}{T}+\frac{1}{d})$log(min{$d$,$T$})
         + if penalty=5, $g_5= h_0 d^{2-2\nu}(\frac{1}{T}+\frac{1}{d})$log(min{$d_k$,$T$})
     + When rank= 'ER' :
         + if penalty=1, $h_1= c_0 h_0$
         + if penalty=2, $h_2= \frac{h_0 d^2}{T^2}$
         + if penalty=3, $h_3= \frac{h_0 d^2}{T^2 d_k^2}$
         + if penalty=4, $h_4= \frac{h_0 d^2}{T^2 d_k^2} + \frac{h_0 d_k^2}{T^2}$
         + if penalty=5, $h_5= \frac{h_0 d^2}{T^2 d_k^2} + \frac{h_0 dd_k^2}{T^2}$
* `delta1` Weakest factor strength, which is the tuning parameter $\nu$ in the penalty functions g above, used for BIC method only

* The function returns factor.num, which is the estimated rank in each dimension.

```{r eval=FALSE}
r.est = Rank.est(xx,r)
model2 = TenFM.est(xx,r.est)  # Use estimated rank to estimate factor

```


## Discussion

- Our source code is now on https://github.com/ZeBang/timeFA. 
- If you have any problems or find any bugs please report on https://github.com/ZeBang/timeFA/issues. Thank you.


