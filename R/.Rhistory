}
}
}
#' Predictions for Tensor Autoregressive Models
#'
#' Prediction based on the tensor autoregressive model or reduced rank MAR(1) model. If \code{rolling = TRUE}, returns the rolling forecasts.
#'@name tenAR.predict
#'@rdname tenAR.predict
#'@aliases tenAR.predict
#'@export
#'@importFrom abind abind
#'@param object a model object returned by \code{tenAR.est()}.
#'@param n.head prediction horizon.
#'@param xx \eqn{T^{\prime} \times d_1 \times \cdots \times d_K} new tensor time series to be used for prediction. Must have at least \code{n.ahead} length.
#'@param rolling TRUE or FALSE, rolling forecast, is FALSE by default.
#'@param n0 only if \code{rolling = TRUE}, the starting point of rolling forecast.
#'@return
#'a tensor time series of length \code{n.head} if \code{rolling = FALSE};
#'
#'a tensor time series of length \eqn{T^{\prime} - n_0 - n.head + 1} if \code{rolling = TRUE}.
#'@seealso 'predict.ar' or 'predict.arima'
#'@examples
#' set.seed(333)
#' dim <- c(2,2,2)
#' t = 20
#' xx <- tenAR.sim(t, dim, R=2, P=1, rho=0.5, cov='iid')
#' est <- tenAR.est(xx, R=1, P=1, method="LSE")
#' pred <- tenAR.predict(est, n.head = 1, xx = xx)
#' # rolling forcast
#' n0 = t - min(50,t/2)
#' pred.rolling <- tenAR.predict(est, n.head = 5, xx = xx, rolling=TRUE, n0)
#'
#' # prediction for reduced rank MAR(1) model
#' dim <- c(2,2)
#' t = 20
#' xx <- tenAR.sim(t, dim, R=1, P=1, rho=0.5, cov='iid')
#' est <- matAR.RR.est(xx, method="RRLSE", k1=1, k2=1)
#' pred <- tenAR.predict(est, n.head = 1, xx = xx)
#' # rolling forcast
#' n0 = t - min(50,t/2)
#' pred.rolling <- tenAR.predict(est, n.head = 5, xx = NULL, rolling=TRUE, n0)
tenAR.predict <- function(object, n.head=1, xx=NULL, rolling=FALSE, n0=NULL){
if (is.null(object$SIGMA)){method = "LSE"} else {method = "MLE"}
if (!is.null(object$A1)){
A <- list(list(list(object$A1, object$A2)))
if (is.null(object$Sig1)){
method = "RRLSE"
} else {
method = "RRMLE"
}
} else if (!is.null(object$coef)){
A <- list(list(object$coef))
method = "VAR"
} else {
A <- object$A
}
if (is.null(xx)){xx = object$data}
if (mode(xx) != "S4") {xx <- rTensor::as.tensor(xx)}
if (rolling == TRUE){
return(predict.rolling(A, xx, n.head, method, n0))
}
P <- length(A)
R <- sapply(c(1:P), function(l){length(A[[l]])})
K <- xx@num_modes - 1
dim <- xx@modes
ttt <- (dim[1]+1):(dim[1]+n.head)
for(tt in ttt){
L1 = 0
for (l in c(1:P)){
if (R[l] == 0) next
L1 <- L1 + Reduce("+",lapply(c(1:R[l]), function(n) {rTensor::ttl(abind::asub(xx, tt-l, 1, drop=FALSE), A[[l]][[n]], (c(1:K) + 1))}))
}
xx <- as.tensor(abind(xx@data, L1@data, along=1))
}
return(abind::asub(xx@data, ttt, 1, drop=FALSE))
}
predict.rolling <- function(A, xx, n.head, method, n0){
if ((method == "RRLSE") || (method == "RRMLE")){
k1 <- rankMatrix(A[[1]][[1]][[1]])
k2 <- rankMatrix(A[[1]][[1]][[2]])
}
P <- length(A)
R <- sapply(c(1:P), function(l){length(A[[l]])})
K <- xx@num_modes - 1
dim <- xx@modes
t <- dim[1]
if(is.null(n0)){n0 = t - min(50,t/2)}
ttt <- (n0):(t - n.head)
for(tt in ttt){
tti <- tt - ttt[1] + 1
print(paste("rolling forcast t =", tti))
if (method == "RRLSE"){
model <- MAR1.RR(abind::asub(xx@data, 1:tt, 1, drop=FALSE), k1, k2)
A <- list(list(list(model$A1, model$A2)))
} else if (method == "RRMLE"){
model <- MAR1.CC(abind::asub(xx@data, 1:tt, 1, drop=FALSE), k1, k2)
A <- list(list(list(model$A1, model$A2)))
} else {
model = tenAR.est(abind::asub(xx@data, 1:tt, 1, drop=FALSE), R, c(P,0), method)
A <- model$A
}
L1 = 0
for (l in c(1:P)){
if (R[l] == 0) next
L1 <- L1 + Reduce("+",lapply(c(1:R[l]), function(n) {rTensor::ttl(abind::asub(xx, tt-l+1, 1, drop=FALSE), A[[l]][[n]], (c(1:K) + 1))}))
}
if (tti == 1){xx.pred = L1@data} else {xx.pred = abind(xx.pred, L1@data, along=1)}
}
return(xx.pred)
}
.getpos <- function(mode, rank){
pos = 0
for (k in c(1:length(mode))){
if (k > 1){mode[k] = mode[k] - 1}
pos = pos + rank[k]*mode[k]
}
return(pos)
}
.getrank <- function(dim){
rank = array(1, length(dim))
for (k in c(1:length(dim))){
if (k > 1){ for (q in c(1:(k-1))){rank[k] = rank[k]*(rev(dim)[q])}}
}
return(rank)
}
.remove.mean <- function(xx){
dim <- xx@modes
m <- apply(xx@data, c(2:xx@num_modes), mean)
mm <- aperm(array(m, c(dim[-1],dim[1])), c(xx@num_modes,c(1:(xx@num_modes-1))))
return(xx - mm)
}
### Helper functions
# myslice <- function(xx, K, start, end){
#   if (K==2){
#     return(xx[start:end,,,drop=FALSE])
#   } else if (K==3){
#     return(xx[start:end,,,,drop=FALSE])
#   } else {
#     stop("not support tensor mode K > 3")
#   }
# }
# mat projection
matAR.PROJ <- function(xx, dim, r, t){
xx.mat <- matrix(xx,t,dim[1]*dim[2])
kroneck <- t(xx.mat[2:t,]) %*% xx.mat[1:(t-1),] %*% solve(t(xx.mat[1:(t-1),]) %*% xx.mat[1:(t-1),])
return(projection(kroneck, r, dim[1],dim[2],dim[1],dim[2]))
}
# Tensor Times List
tl <- function(x, list_mat, k = NULL){
if (is.null(k)){
tensor(tensor(tensor(x, list_mat[[1]], 2, 2), list_mat[[2]], 2, 2), list_mat[[3]], 2, 2)
} else if (k == 1){
tensor(tensor(x, list_mat[[1]], 3, 2), list_mat[[2]], 3, 2)
} else if (k == 2){
aperm(tensor(tensor(x, list_mat[[1]], 2, 2), list_mat[[2]], 3, 2),c(1,3,2,4))
} else if (k == 3){
aperm(tensor(tensor(x, list_mat[[1]], 2, 2), list_mat[[2]], 2, 2),c(1,3,4,2))
} else {
stop("not support tensor mode K > 3")
}
}
# standard error extraction
covtosd <- function(cov, dim, R){
K <- length(dim)
P <- length(R)
sd = list()
for (p in c(1:P)){
if (is.na(R[p])) stop("p != length(R)")
if (R[p] == 0) next
sd[[p]] <- lapply(1:R[p], function(j) {lapply(1:K, function(i) {list()})})
}
for (i in c(1:P)){
for (j in c(1:R[i])){
for (k in c(1:K)){
left <- sum(dim^2)*sum(R[0:(i-1)]) + sum(dim^2)*(j-1) + sum((dim^2)[1:(k-1)])+1
right <- sum(dim^2)*sum(R[0:(i-1)]) + sum(dim^2)*(j-1) + sum((dim^2)[1:k])
sd[[i]][[j]][[k]] <- array(sqrt(diag(cov)[left:right]), c(dim[k], dim[k]))
}
}
}
return(sd)
}
# Permutation matrix em
em <- function(m,n,i,j){
## m,n,i,j set \eqn{m \times n} zero matrix with \eqn{A_{ij} = 1}
## return: Permutation matrix em such that \eqn{A_{ij} = 1} and other entries equals 0.
mat <- matrix(0,m,n)
mat[i,j] <- 1
return(mat)
}
# Permutation matrix pm
pm <- function(m,n){
## m: an array of dimensions of matrices \eqn{A_1,A_2,\cdots,A_k}
## n: length of time
## return: Permutation matrix pm
mat <- matrix(0,m*n,m*n)
for (i in c(1:n)){
for (j in c(1:m)){
mat <- mat + kronecker(em(n,m,i,j),t(em(n,m,i,j)))
}
}
return(mat)
}
# rearrangement operator for tensor
trearrange <- function(A,dim){
m1 = dim[1]; m2 = dim[2]; m3 = dim[3]
n1 = m1; n2 = m2; n3 = m3
m <- nrow(A)
n <- ncol(A)
if(n!=n1*n2*n3 | m!=m1*m2*m3){
stop("wrong dimention with your input Phi for rearrangement")
}
ans <- divide(A,m1,n1)
dim <- c(m1*n1,m2*n2,m3*n3)
t <- array(0, dim)
for (i in c(1:m1)){
for (j in c(1:n1)){
t[(j-1)*m1+i,,] <- mrearrange(ans[[i]][[j]],m2,m3,n2,n3)
}
}
return(t)
}
divide <- function(A,m,n){
# the inner function of "trearrange"
c <- dim(A)[1]/m
l <- dim(A)[2]/n
tmp <- lapply(1:m, function(i){
lapply(1:n, function(j){
A[((i-1)*c+1):(i*c),((j-1)*l+1):(j*l)]
})
})
return(tmp)
}
mrearrange <- function(A,m1,m2,n1,n2){
# the inner function of "projection"
# A: m1m2*n1n2
# B: m1*n1
# C: m2*n2
# A \approx B \otimes C
# return RA
m <- nrow(A)
n <- ncol(A)
if(n!=n1*n2 | m!=m1*m2){
stop("error m")
}
ans <- matrix(NA, m1*n1, m2*n2)
for(i in 1:m1){
for(j in 1:n1){
ans[(j-1)*m1+i,] <- t(as.vector(A[(i-1)*m2+1:m2,(j-1)*n2+1:n2]))
}
}
return(ans)
}
projection <- function(M,r,m1,m2,n1,n2){
# the inner function of MAR1.projection
# M: m1m2*n1n2
# B: m1*n1
# C: m2*n2
# M \approx B \otimes C
# return B and C
RA <- mrearrange(M,m1,m2,n1,n2)
RA.svd <- svd(RA,nu=r,nv=r)
A <- list()
for (i in c(1:r)){
A[[i]] <- list(matrix(RA.svd$v[,i], m2, n2), matrix(RA.svd$u[,i] * RA.svd$d[i], m1, n1))
}
for (j in c(1:r)){
A[[j]] <- rev(A[[j]])
a <- c()
for (i in c(1:2)){
m <- A[[j]][[i]]
if (i != 2){
a[i] <- svd(m,nu=0,nv=0)$d[1]
A[[j]][[i]] <- m/a[i]
} else {
A[[j]][[i]] <- m * prod(a)
}
}
}
return(A)
}
ten.proj <- function(tt, dim, R){
## inner func of "TenAR.proj"
cpd <- rTensor::cp(rTensor::as.tensor(tt), num_components = R)
lam <- cpd$lambdas
A.proj <- list()
for (j in c(1:R)){
u1 <- cpd$U[[1]][,j]
u2 <- cpd$U[[2]][,j]
u3 <- cpd$U[[3]][,j]
f1 <- sqrt(sum(cpd$U[[1]][,j]^2))
f2 <- sqrt(sum(cpd$U[[2]][,j]^2))
f3 <- sqrt(sum(cpd$U[[3]][,j]^2))
a1 <- u1/f1
a2 <- u2/f2
a3 <- u3*f1*f2*lam[j]
A.proj[[j]] <- list(matrix(a1,dim[1],dim[1]),
matrix(a2,dim[2],dim[2]),
matrix(a3,dim[3],dim[3]))
}
return(fro.order(A.proj))
}
fro.rescale <- function(A){
r <- length(A)
k <- length(A[[1]])
for (j in c(1:r)){
a <- c()
for (i in c(1:k)){
m <- A[[j]][[i]]
if (i < k ){
a[i] <- norm(m,"f")
A[[j]][[i]] <- m/a[i]
} else if (i == k){
A[[j]][[i]] <- m * prod(a)
} else {
print("WRONG dimension")
}
}
}
return(A)
}
svd.rescale <- function(A){
r <- length(A)
k <- length(A[[1]])
for (j in c(1:r)){
a <- c()
for (i in c(1:k)){
m <- A[[j]][[i]]
if (i < k ){
a[i] <- svd(m,nu=0,nv=0)$d[1]
A[[j]][[i]] <- m/a[i]
} else if (i == k){
A[[j]][[i]] <- m * prod(a)
} else {
print("WRONG dimension")
}
}
}
return(A)
}
eigen.rescale <- function(A){
r <- length(A)
k <- length(A[[1]])
for (j in c(1:r)){
a <- c()
for (i in c(1:k)){
m <- A[[j]][[i]]
if (i < k ){
a[i] <- eigen(m)$values[1]
A[[j]][[i]] <- m/a[i]
} else if (i == k){
A[[j]][[i]] <- m * prod(a)
} else {
print("WRONG dimension")
}
}
}
return(A)
}
fro.order <- function(A){
R <- length(A)
K <- length(A[[1]])
if (R == 1){return(A)}
A.norm <- c()
for (j in c(1:R)){
A.norm[j] <- Reduce("*",lapply(c(1:K), function(k) { norm(A[[j]][[k]], 'f')}))
}
order.norm <- order(A.norm, decreasing=TRUE)
A.temp <- A
for (j in c(1:R)){
A[[j]] <- A.temp[[order.norm[j]]]
}
return(A)
}
ten.dis.A <- function(A, B, R, K){
P = length(R)
dis <- 0
for (p in c(1:P)){
for (r in c(1:R[p])){
for (k in c(1:K)){
dis <- dis + min(sum((A[[p]][[r]][[k]] - B[[p]][[r]][[k]])^2), sum((A[[p]][[r]][[k]] + B[[p]][[r]][[k]])^2))
}
}
}
return(sqrt(dis))
}
ten.dis.phi <- function(phi.A, phi.B){
P <- length(phi.A)
dis <- 0
for (i in c(1:P)){
dis <- dis + sqrt(sum((phi.A[[i]] - phi.B[[i]])^2))
}
return(dis)
}
ten.res <- function(xx,A,P,R,K,t){
L1 = 0
for (l in c(1:P)){
if (R[l] == 0) next
L1 <- L1 + Reduce("+",lapply(c(1:R[l]), function(n) {rTensor::ttl(abind::asub(xx, (1+P-l):(t-l), 1, drop=FALSE), A[[l]][[n]], (c(1:K) + 1))}))
}
res <- abind::asub(xx, (1+P):(t), 1, drop=FALSE) - L1
return(res)
}
M.eigen <- function(A, R, P, dim){
phi <- list()
PP = P
for (i in c(1:P)){
if (sum(R[i:length(R)]) == 0){
PP = i-1
break
}
if (R[i] == 0){
phi[[i]] = pracma::zeros(prod(dim))
} else {
phi[[i]] <- Reduce("+", lapply(1:R[i], function(j) {rTensor::kronecker_list(rev(A[[i]][[j]]))}))
}
if (i == 1){M <- phi[[1]]} else {M <- cbind(M, phi[[i]])}
}
K <- dim(phi[[1]])[[1]]
M <- rbind(M, cbind(diag(K*(PP-1)), array(0,c(K*(PP-1),K))))
return(max(Mod(eigen(M, only.values = TRUE)$values)))
}
specRadius <- function(M){
return(max(Mod(eigen(M, only.values = TRUE)$values)))
}
likelihood <- function(xx, A, Sigma){
r <- length(A[[1]])
dd <- dim(xx)
t <- dd[1]
dim <- dd[-1]
k <- length(dd[-1])
i = 1
res <- ten.res(xx,A,P=1,R=r,K=k,t=t)
Sigma.inv <- lapply(1:k, function (i) {solve(Sigma[[i]])})
ll <- tl(res, Sigma.inv)
l1 <- sum(diag(tensor(ll, res, c(1:4)[-(i+1)],c(1:4)[-(i+1)])))
l2 <- 0
for (i in c(1:k)){
l2 = l2 - prod(dim[-i]) * (t-1) * (log(det(Sigma[[i]])))
}
return((l2 - l1)/2)
}
initializer <- function(xx, k1=1, k2=1){
print(dim(xx))
PROJ = MAR1.PROJ(xx)
if (specRadius(PROJ$A1)*specRadius(PROJ$A2) < 1){
return(list(A1=PROJ$A1,A2=PROJ$A2))
}
MAR = MAR1.LS(xx)
if (specRadius(MAR$A1)*specRadius(MAR$A2) < 1){
return(list(A1=MAR$A1,A2=MAR$A2))
}
RRMAR = MAR1.RR(xx, k1, k2)
if (specRadius(MAR1.RR$A1)*specRadius(MAR1.RR$A2) < 1){
return(list(A1=MAR1.RR$A1,A2=MAR1.RR$A2))
}
stop('causality condition of initializer fails.')
}
likelihood.lse <- function(fres, s, d, t){
l1 <- fres/2/s^2
l2 <- -(t - 1)*d*log(2*pi*s^2)/2
return(l2 - l1)
}
IC <- function(xx,res,r,t,dim){
N <- prod(dim)
ic <- log(sum((res)^2)/(N*t))/2 + sum(r)*log(t)/t
return(ic)
}
dim <- c(2,2)
t = 20
xx <- tenAR.sim(t, dim, R=1, P=1, rho=0.5, cov='iid')
est <- matAR.RR.est(xx, method="RRLSE", k1=1, k2=1)
pred <- tenAR.predict(est, n.head = 1)
initializer <- function(xx, k1=1, k2=1){
PROJ = MAR1.PROJ(xx)
if (specRadius(PROJ$A1)*specRadius(PROJ$A2) < 1){
return(list(A1=PROJ$A1,A2=PROJ$A2))
}
MAR = MAR1.LS(xx)
if (specRadius(MAR$A1)*specRadius(MAR$A2) < 1){
return(list(A1=MAR$A1,A2=MAR$A2))
}
RRMAR = MAR1.RR(xx, k1, k2)
if (specRadius(MAR1.RR$A1)*specRadius(MAR1.RR$A2) < 1){
return(list(A1=MAR1.RR$A1,A2=MAR1.RR$A2))
}
stop('causality condition of initializer fails.')
}
dim <- c(2,2)
t = 20
xx <- tenAR.sim(t, dim, R=1, P=1, rho=0.5, cov='iid')
est <- matAR.RR.est(xx, method="RRLSE", k1=1, k2=1)
pred <- tenAR.predict(est, n.head = 1)
# rolling forcast
n0 = t - min(50,t/2)
pred.rolling <- tenAR.predict(est, n.head = 5, rolling=TRUE, n0=n0)
devtools::load_all()
devtools::check()
devtools::document()
devtools::document()
devtools::build_manual()
devtools::load_all()
devtools::document()
devtools::document()
devtools::build_manual()
devtools::check()
devtools::test()
devtools::spell_check()
devtools::build()
devtools::load_all()
devtools::document()
devtools::build_manual()
